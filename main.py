import math
import random
from typing import Any


INF = 9999999999999999

class DirectedWeightedGraph:
    def __init__(self, vertices: list, edges: set[tuple]):
        self.__edges = edges
        self.__vertices = vertices

    def add_vertice(self, vertice):
        if vertice in self.__vertices:
            raise GraphUnsupportedOperationError(f"Vertice {vertice} has already exists in graph")
        self.__vertices.append(vertice)

    def get_vertices_len(self) -> int:
        return len(self.__vertices)

    def add_vertices(self, vertices: list):
        for vertice in vertices:
            self.add_vertice(vertice)

    def remove_vertice(self, vertice):
        self.__vertices.remove(vertice)

    def get_vertices(self):
        return self.__vertices

    def get_edges_len(self):
        return len(self.__edges)

    def add_edge(self, weight: int, vertice_1, vertice_2):
        if not vertice_1 in self.__vertices:
            raise GraphUnsupportedOperationError(f"Graph does not have vertice: {vertice_1}")
        if not vertice_2 in self.__vertices:
            raise GraphUnsupportedOperationError(f"Graph does not have vertice: {vertice_2}")
        self.__edges.add((weight, vertice_1, vertice_2))

    def add_edges(self, *edges: tuple[int, Any, Any]):
        for edge in edges:
            self.add_edge(edge[0], edge[1], edge[2])

    def remove_edge(self, edge):
        self.__edges.remove(edge)

    def __find_edges(self, **param) -> list:
        start_vertice = param["start_vertice"]
        end_vertice = param["end_vertice"]
        if start_vertice is not None and end_vertice is not None:
            return list(filter(lambda edge: edge[1] == start_vertice and edge[2] == end_vertice, self.__edges))
        if start_vertice is not None:
            return list(filter(lambda edge: edge[1] == start_vertice, self.__edges))
        return list(self.__edges)

    def get_adjacency_matrix(self) -> list[list]:
        matrix = []
        for vertice_1 in self.__vertices:
            row = []
            for vertice_2 in self.__vertices:
                if vertice_1 == vertice_2:
                    row.append(0)
                    continue
                edges = self.__find_edges(start_vertice=vertice_1, end_vertice=vertice_2)
                if len(edges) == 0:
                    row.append(INF) # I think it is the biggest number :)
                    continue
                if len(edges) > 1:
                    raise GraphError(f"Edges more that 1 (current {len(edges)})")
                row.append(edges[0][0])
            matrix.append(row)
        return matrix

    @staticmethod
    def create_empty() -> DirectedWeightedGraph:
        return DirectedWeightedGraph([], set())
    @staticmethod
    def generate(n: int, density: float, min_weight = 1, max_weight = 100, graph = None) -> DirectedWeightedGraph:
        if graph is None:
            graph = DirectedWeightedGraph.create_empty()
            graph.add_vertices(list(range(1, n + 1)))
        c = 2
        probability = c * math.log(n) / n
        if probability >= 1:
            raise GraphError("Ohh, probability is more than 100%")
        vertices = graph.get_vertices()
        random.shuffle(vertices)
        for vertice_1 in vertices:
            random.shuffle(vertices)
            for vertice_2 in vertices:
                if not random.random() < probability:
                    continue
                if len(graph.__find_edges(start_vertice=vertice_1, end_vertice=vertice_2)) > 0:
                    continue
                if graph.get_edges_len() >= density * n * (n - 1):
                    break
                graph.add_edge(random.randint(min_weight, max_weight), vertice_1, vertice_2)
        if graph.get_edges_len() < density * n * (n - 1):
            return DirectedWeightedGraph.generate(n, density, min_weight, max_weight, graph)
        return graph


class GraphError(Exception):
    pass


class GraphUnsupportedOperationError(Exception):
    pass

class AlgorithmFloydWorshell:

    def __init__(self, graph: DirectedWeightedGraph):
        self.graph = graph

    def work(self) -> list[list]:
        matrix = self.graph.get_adjacency_matrix()
        for k in range(0, self.graph.get_vertices_len()):
            for i in range(0, self.graph.get_vertices_len()):
                for j in range(0, self.graph.get_vertices_len()):
                    matrix[i][j] = min(matrix[i][j], matrix[i][k] + matrix[k][j])
        return matrix

# this method (pretty_print_matrix) is generated by AI
def pretty_print_matrix(matrix: list[list], vertices: list):
    n = len(vertices)

    if len(matrix) != n or any(len(row) != n for row in matrix):
        raise ValueError("Matrix must be NxN and match vertices count")

    def fmt(x):
        return "∞" if x == INF else str(x)

    cell_width = max(len(fmt(x)) for row in matrix for x in row)
    label_width = max(len(str(v)) for v in vertices)

    # column template (IMPORTANT)
    col_fmt = f"{{:>{cell_width}}}"

    # --- header ---
    print(
        " " * (label_width + 3) +
        " ".join(col_fmt.format(v) for v in vertices)
    )

    # --- rows ---
    for i, row in enumerate(matrix):
        if i == 0:
            l, r = "⎡", "⎤"
        elif i == n - 1:
            l, r = "⎣", "⎦"
        else:
            l, r = "⎢", "⎥"

        print(
            f"{vertices[i]:>{label_width}}  {l} " +
            " ".join(col_fmt.format(fmt(x)) for x in row) +
            f" {r}"
        )


def main():
    # graph = DirectedWeightedGraph.create_empty()
    # graph.add_vertices('a', 'b', 'c', 'd', 'e')
    # graph.add_edges(
    #     (4, 'a', 'b'),
    #     (2, 'b', 'c')
    # )
    graph = DirectedWeightedGraph.generate(11, 0.99, 87, 100)
    algorithm = AlgorithmFloydWorshell(graph)
    print("Graph adjacency matrix:")
    pretty_print_matrix(graph.get_adjacency_matrix(), graph.get_vertices())
    print("Output of algorithm:")
    pretty_print_matrix(algorithm.work(), graph.get_vertices())

if __name__ == "__main__":
    main()
